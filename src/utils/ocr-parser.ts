import { z } from "zod";

export const ParsedAccountSchema = z.object({
  raw: z.string(),
  normalized: z.string(),
  context: z.string(),
});

export type ParsedAccount = z.infer<typeof ParsedAccountSchema>;

export function sanitizeText(text: string): string {
  // Regex to remove common temporal data formats
  const temporalPatterns = [
    /\b\d{1,2}\/\d{1,2}\/\d{2,4}(?:, \d{1,2}:\d{2} (?:AM|PM))?\b/g, // e.g., 7/23/24, 3:58 PM or 07/23/2024
    /\b\d{4}-\d{2}-\d{2}(?: \d{2}:\d{2}:\d{2})?\b/g,             // e.g., 2024-07-23 15:58:00
    /Report Date:\s*\d{1,2}\/\d{1,2}\/\d{2,4}/gi,                // e.g., Report Date: 07/23/2024
    /\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2},\s+\d{4}\b/gi, // e.g., July 23, 2024
    /\b\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}\b/gi, // e.g., 23 July 2024
    /\b\d{1,2}:\d{2}(?::\d{2})?\s*(?:AM|PM|UTC|GMT)?\b/gi,       // e.g., 3:58 PM, 15:58:00
  ];

  // Regex to remove common system/source attribution phrases
  const attributionPatterns = [
    /\bExperian\b/gi,
    /\bTransUnion\b/gi,
    /\bEquifax\b/gi,
    /\bGenerated by\s+\S+/gi, // e.g., Generated by X
    /\bPowered by\s+\S+/gi,   // e.g., Powered by Y
  ];

  let sanitized = text;

  // Apply temporal data removal
  for (const pattern of temporalPatterns) {
    sanitized = sanitized.replace(pattern, '');
  }

  // Apply attribution removal
  for (const pattern of attributionPatterns) {
    sanitized = sanitized.replace(pattern, '');
  }
  console.log("OCR-PARSER: sanitizeText input:", text);
  const sanitizedText = sanitized;
  console.log("OCR-PARSER: sanitizeText output:", sanitizedText);

  return sanitized
    .replace(/[^\S\r\n]+/g, ' ')      // collapse weird spaces
    .replace(/[\u200B-\u200D\uFEFF]/g, '') // remove zero-width chars
    .replace(/[^ -~\r\n]/g, '');      // strip non-printable
}

const patterns = [
  /Account\s+\+\s+(\d{5,})(X{2,}|\d*)/gi,                  // e.g., Account + 517805XXXXXXXXXX
  /Account Number\s+(\d{4,})(X{2,}|\d*)/gi,                // e.g., Account Number 627804XXXX
  /\b(\d{5,})(X{2,}|\d*)\b/g,                              // e.g., 517805XXXXXXXXXX in isolation
];

export const parseAccountNumbers = (text: string): ParsedAccount[] => {
  const lines = text.split(/\r?\n/);
  const matches: ParsedAccount[] = [];

  for (const [i, line] of lines.entries()) {
    for (const pattern of patterns) {
      let match: RegExpExecArray | null;
      while ((match = pattern.exec(line))) {
        const raw = match[0];
        const account = match[1] + (match[2] || '');
        const context = lines.slice(Math.max(i - 1, 0), i + 2).join(' ').trim();

        const parsedAccount: ParsedAccount = {
          raw,
          normalized: account,
          context,
        };
        console.log("parseAccountNumbers - raw:", raw);
        console.log("parseAccountNumbers - account:", account);
        console.log("parseAccountNumbers - context:", context);
        try {
          ParsedAccountSchema.parse(parsedAccount);
          matches.push(parsedAccount);
        } catch (error) {
          console.error("ParsedAccount validation error:", error);
          // Optionally, handle the error, e.g., skip invalid accounts
        }
      }
    }
  }

  // Optional: deduplicate based on normalized account
  const unique = new Map<string, ParsedAccount>();
  for (const match of matches) {
    if (!unique.has(match.normalized)) {
      unique.set(match.normalized, match);
    }
  }

  return Array.from(unique.values());
};