create extension if not exists "http" with schema "extensions";

create extension if not exists "pg_walinspect" with schema "extensions";

create extension if not exists "pgjwt" with schema "extensions";

create extension if not exists "postgres_fdw" with schema "extensions";

create extension if not exists "wrappers" with schema "extensions";


create schema if not exists "private";


create extension if not exists "vector" with schema "public" version '0.8.0';

create sequence "public"."documents_id_seq";

drop policy "Allow authenticated users to insert their own credit reports" on "public"."credit_reports";

drop function if exists "public"."check_admin_role"(user_id uuid);

create table "public"."credit_bureau" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text,
    "address" text,
    "city" text,
    "state" text,
    "zip" text,
    "phone_number" text
);


alter table "public"."credit_bureau" enable row level security;

create table "public"."dispute_letter" (
    "fist_name" text default 'John'::text,
    "last_name" text default 'Doe'::text,
    "address" text default '123 Street'::text,
    "city" text default 'Los Angeles'::text,
    "state" text default 'CA'::text,
    "zip" text default '''00000''::text'::text,
    "email" text default 'JohnDoe@email.com'::text,
    "tradelines" json,
    "created_on" date not null default now(),
    "user_id" uuid not null,
    "id" uuid not null default gen_random_uuid(),
    "lob_id" text,
    "delivery_status" text
);


alter table "public"."dispute_letter" enable row level security;

create table "public"."dispute_log" (
    "id" uuid not null default gen_random_uuid(),
    "operation" text not null,
    "user_id" uuid,
    "dispute_id" uuid,
    "old_data" jsonb,
    "new_data" jsonb,
    "changed_at" timestamp without time zone default now()
);


alter table "public"."dispute_log" enable row level security;

create table "public"."documents" (
    "id" bigint not null default nextval('documents_id_seq'::regclass),
    "content" text,
    "metadata" jsonb,
    "embedding" vector(1536),
    "user_id" uuid not null
);


alter table "public"."documents" enable row level security;

create table "public"."profiles" (
    "id" uuid default gen_random_uuid(),
    "email" text default ''::text,
    "created_at" timestamp with time zone default (now() AT TIME ZONE 'utc'::text),
    "phone_number" text default ''::text,
    "address1" text default ''::text,
    "ssn" text default ''::text,
    "city" text default ''::text,
    "state" text default ''::text,
    "zip" numeric,
    "first_name" text default ''::text,
    "last_name" text default ''::text,
    "phone" text default ''::text,
    "user_id" uuid not null default gen_random_uuid(),
    "address2" text default ''::text,
    "dob" date,
    "is_super_admin" text default 'False'::text,
    "role" text not null default 'user'::text
);


alter table "public"."profiles" enable row level security;

create table "public"."tradelines" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "creditor_name" text,
    "account_balance" text default '0'::text,
    "account_type" text,
    "account_status" text,
    "created_at" text,
    "dispute_count" integer default 0,
    "credit_limit" text,
    "monthly_payment" text,
    "account_number" text,
    "account_condition" text,
    "credit_bureau" text
);


alter table "public"."tradelines" enable row level security;

create table "public"."transcripts" (
    "id" uuid not null,
    "title" text,
    "content" text,
    "created_at" timestamp without time zone,
    "updated_at" timestamp without time zone,
    "tags" text[],
    "transcript_file" bytea
);


alter table "public"."transcripts" enable row level security;

create table "public"."user_documents" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone default (now() AT TIME ZONE 'utc'::text),
    "document_type" text,
    "file_path" text
);


alter table "public"."user_documents" enable row level security;

create table "public"."user_roles" (
    "user_id" uuid not null,
    "role" text not null,
    "email" text
);


alter table "public"."user_roles" enable row level security;

alter table "public"."audit_history" enable row level security;

alter table "public"."disputes" enable row level security;

alter table "public"."user_personal_info" drop column "first_name";

alter table "public"."user_personal_info" drop column "last_name";

alter table "public"."user_personal_info" add column "first_Name" text;

alter table "public"."user_personal_info" add column "last_Name" text;

alter table "public"."user_personal_info" alter column "address" drop not null;

alter table "public"."user_personal_info" alter column "city" drop not null;

alter table "public"."user_personal_info" alter column "state" drop not null;

alter table "public"."user_personal_info" alter column "zip" drop not null;

alter table "public"."user_personal_info" enable row level security;

alter sequence "public"."documents_id_seq" owned by "public"."documents"."id";

CREATE INDEX audit_history_performed_by_idx ON public.audit_history USING btree (performed_by);

CREATE UNIQUE INDEX credit_bureau_pkey ON public.credit_bureau USING btree (id);

CREATE UNIQUE INDEX dispute_letter_pkey ON public.dispute_letter USING btree (id);

CREATE UNIQUE INDEX dispute_log_pkey ON public.dispute_log USING btree (id);

CREATE UNIQUE INDEX disputes_user_id_key ON public.disputes USING btree (user_id);

CREATE UNIQUE INDEX documents_pkey ON public.documents USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (user_id);

CREATE UNIQUE INDEX tradelines_pkey ON public.tradelines USING btree (id);

CREATE INDEX tradelines_user_id_creditor_account_number_idx ON public.tradelines USING btree (user_id, creditor_name, account_number);

CREATE INDEX tradelines_user_id_idx ON public.tradelines USING btree (user_id);

CREATE UNIQUE INDEX tradelines_user_id_key ON public.tradelines USING btree (user_id);

CREATE UNIQUE INDEX transcripts_pkey ON public.transcripts USING btree (id);

CREATE UNIQUE INDEX unique_tradeline_per_user ON public.tradelines USING btree (user_id, account_number, creditor_name);

CREATE UNIQUE INDEX user_documents_pkey ON public.user_documents USING btree (id);

CREATE UNIQUE INDEX user_documents_user_id_key ON public.user_documents USING btree (user_id);

CREATE UNIQUE INDEX user_documents_user_id_key1 ON public.user_documents USING btree (user_id);

CREATE UNIQUE INDEX user_personal_info_email_key ON public.user_personal_info USING btree (email);

CREATE UNIQUE INDEX user_roles_email_key ON public.user_roles USING btree (email);

CREATE UNIQUE INDEX user_roles_pkey ON public.user_roles USING btree (user_id, role);

alter table "public"."credit_bureau" add constraint "credit_bureau_pkey" PRIMARY KEY using index "credit_bureau_pkey";

alter table "public"."dispute_letter" add constraint "dispute_letter_pkey" PRIMARY KEY using index "dispute_letter_pkey";

alter table "public"."dispute_log" add constraint "dispute_log_pkey" PRIMARY KEY using index "dispute_log_pkey";

alter table "public"."documents" add constraint "documents_pkey" PRIMARY KEY using index "documents_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."tradelines" add constraint "tradelines_pkey" PRIMARY KEY using index "tradelines_pkey";

alter table "public"."transcripts" add constraint "transcripts_pkey" PRIMARY KEY using index "transcripts_pkey";

alter table "public"."user_documents" add constraint "user_documents_pkey" PRIMARY KEY using index "user_documents_pkey";

alter table "public"."user_roles" add constraint "user_roles_pkey" PRIMARY KEY using index "user_roles_pkey";

alter table "public"."dispute_letter" add constraint "dispute_letter_user_id_fkey" FOREIGN KEY (user_id) REFERENCES user_personal_info(user_id) ON DELETE CASCADE not valid;

alter table "public"."dispute_letter" validate constraint "dispute_letter_user_id_fkey";

alter table "public"."disputes" add constraint "disputes_user_id_key" UNIQUE using index "disputes_user_id_key";

alter table "public"."tradelines" add constraint "tradelines_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."tradelines" validate constraint "tradelines_user_id_fkey";

alter table "public"."tradelines" add constraint "tradelines_user_id_key" UNIQUE using index "tradelines_user_id_key";

alter table "public"."tradelines" add constraint "unique_tradeline_per_user" UNIQUE using index "unique_tradeline_per_user";

alter table "public"."user_documents" add constraint "user_documents_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."user_documents" validate constraint "user_documents_user_id_fkey";

alter table "public"."user_documents" add constraint "user_documents_user_id_key" UNIQUE using index "user_documents_user_id_key";

alter table "public"."user_documents" add constraint "user_documents_user_id_key1" UNIQUE using index "user_documents_user_id_key1";

alter table "public"."user_personal_info" add constraint "user_personal_info_email_key" UNIQUE using index "user_personal_info_email_key";

alter table "public"."user_roles" add constraint "user_roles_email_key" UNIQUE using index "user_roles_email_key";

alter table "public"."user_roles" add constraint "user_roles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."user_roles" validate constraint "user_roles_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.fetch_tradelines(user_id bigint)
 RETURNS TABLE(account_number text, creditor text, date_opened timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT account_number, creditor, date_opened
    FROM tradelines
    WHERE user_id = user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_documents(query_embedding vector, match_count integer DEFAULT NULL::integer, filter jsonb DEFAULT '{}'::jsonb)
 RETURNS TABLE(id bigint, content text, metadata jsonb, similarity double precision)
 LANGUAGE plpgsql
AS $function$
#variable_conflict use_column
begin
  return query
  select
    id,
    content,
    metadata,
    1 - (documents.embedding <=> query_embedding) as similarity
  from documents
  where metadata @> filter
  order by documents.embedding <=> query_embedding
  limit match_count;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.prevent_inactive_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public', 'auth'
AS $function$
BEGIN
    -- Function logic here
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_modified()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
    NEW.last_modified = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_dispute_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO public.dispute_log(operation, user_id, dispute_id, new_data)
        VALUES ('INSERT', NEW.user_id, NEW.id, to_jsonb(NEW));
        RETURN NEW;
        
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO public.dispute_log(operation, user_id, dispute_id, old_data, new_data)
        VALUES ('UPDATE', NEW.user_id, NEW.id, to_jsonb(OLD), to_jsonb(NEW));
        RETURN NEW;

    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO public.dispute_log(operation, user_id, dispute_id, old_data)
        VALUES ('DELETE', OLD.user_id, OLD.id, to_jsonb(OLD));
        RETURN OLD;
    END IF;

    RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_retention_date()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_catalog'
AS $function$
BEGIN
    NEW.retention_date := NEW.created_at + INTERVAL '5 years';
    RETURN NEW;
END;
$function$
;

grant delete on table "public"."credit_bureau" to "anon";

grant insert on table "public"."credit_bureau" to "anon";

grant references on table "public"."credit_bureau" to "anon";

grant select on table "public"."credit_bureau" to "anon";

grant trigger on table "public"."credit_bureau" to "anon";

grant truncate on table "public"."credit_bureau" to "anon";

grant update on table "public"."credit_bureau" to "anon";

grant delete on table "public"."credit_bureau" to "authenticated";

grant insert on table "public"."credit_bureau" to "authenticated";

grant references on table "public"."credit_bureau" to "authenticated";

grant select on table "public"."credit_bureau" to "authenticated";

grant trigger on table "public"."credit_bureau" to "authenticated";

grant truncate on table "public"."credit_bureau" to "authenticated";

grant update on table "public"."credit_bureau" to "authenticated";

grant delete on table "public"."credit_bureau" to "service_role";

grant insert on table "public"."credit_bureau" to "service_role";

grant references on table "public"."credit_bureau" to "service_role";

grant select on table "public"."credit_bureau" to "service_role";

grant trigger on table "public"."credit_bureau" to "service_role";

grant truncate on table "public"."credit_bureau" to "service_role";

grant update on table "public"."credit_bureau" to "service_role";

grant delete on table "public"."dispute_letter" to "anon";

grant insert on table "public"."dispute_letter" to "anon";

grant references on table "public"."dispute_letter" to "anon";

grant select on table "public"."dispute_letter" to "anon";

grant trigger on table "public"."dispute_letter" to "anon";

grant truncate on table "public"."dispute_letter" to "anon";

grant update on table "public"."dispute_letter" to "anon";

grant delete on table "public"."dispute_letter" to "authenticated";

grant insert on table "public"."dispute_letter" to "authenticated";

grant references on table "public"."dispute_letter" to "authenticated";

grant select on table "public"."dispute_letter" to "authenticated";

grant trigger on table "public"."dispute_letter" to "authenticated";

grant truncate on table "public"."dispute_letter" to "authenticated";

grant update on table "public"."dispute_letter" to "authenticated";

grant delete on table "public"."dispute_letter" to "service_role";

grant insert on table "public"."dispute_letter" to "service_role";

grant references on table "public"."dispute_letter" to "service_role";

grant select on table "public"."dispute_letter" to "service_role";

grant trigger on table "public"."dispute_letter" to "service_role";

grant truncate on table "public"."dispute_letter" to "service_role";

grant update on table "public"."dispute_letter" to "service_role";

grant delete on table "public"."dispute_log" to "anon";

grant insert on table "public"."dispute_log" to "anon";

grant references on table "public"."dispute_log" to "anon";

grant select on table "public"."dispute_log" to "anon";

grant trigger on table "public"."dispute_log" to "anon";

grant truncate on table "public"."dispute_log" to "anon";

grant update on table "public"."dispute_log" to "anon";

grant delete on table "public"."dispute_log" to "authenticated";

grant insert on table "public"."dispute_log" to "authenticated";

grant references on table "public"."dispute_log" to "authenticated";

grant select on table "public"."dispute_log" to "authenticated";

grant trigger on table "public"."dispute_log" to "authenticated";

grant truncate on table "public"."dispute_log" to "authenticated";

grant update on table "public"."dispute_log" to "authenticated";

grant delete on table "public"."dispute_log" to "service_role";

grant insert on table "public"."dispute_log" to "service_role";

grant references on table "public"."dispute_log" to "service_role";

grant select on table "public"."dispute_log" to "service_role";

grant trigger on table "public"."dispute_log" to "service_role";

grant truncate on table "public"."dispute_log" to "service_role";

grant update on table "public"."dispute_log" to "service_role";

grant delete on table "public"."documents" to "anon";

grant insert on table "public"."documents" to "anon";

grant references on table "public"."documents" to "anon";

grant select on table "public"."documents" to "anon";

grant trigger on table "public"."documents" to "anon";

grant truncate on table "public"."documents" to "anon";

grant update on table "public"."documents" to "anon";

grant delete on table "public"."documents" to "authenticated";

grant insert on table "public"."documents" to "authenticated";

grant references on table "public"."documents" to "authenticated";

grant select on table "public"."documents" to "authenticated";

grant trigger on table "public"."documents" to "authenticated";

grant truncate on table "public"."documents" to "authenticated";

grant update on table "public"."documents" to "authenticated";

grant delete on table "public"."documents" to "service_role";

grant insert on table "public"."documents" to "service_role";

grant references on table "public"."documents" to "service_role";

grant select on table "public"."documents" to "service_role";

grant trigger on table "public"."documents" to "service_role";

grant truncate on table "public"."documents" to "service_role";

grant update on table "public"."documents" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."tradelines" to "anon";

grant insert on table "public"."tradelines" to "anon";

grant references on table "public"."tradelines" to "anon";

grant select on table "public"."tradelines" to "anon";

grant trigger on table "public"."tradelines" to "anon";

grant truncate on table "public"."tradelines" to "anon";

grant update on table "public"."tradelines" to "anon";

grant delete on table "public"."tradelines" to "authenticated";

grant insert on table "public"."tradelines" to "authenticated";

grant references on table "public"."tradelines" to "authenticated";

grant select on table "public"."tradelines" to "authenticated";

grant trigger on table "public"."tradelines" to "authenticated";

grant truncate on table "public"."tradelines" to "authenticated";

grant update on table "public"."tradelines" to "authenticated";

grant delete on table "public"."tradelines" to "service_role";

grant insert on table "public"."tradelines" to "service_role";

grant references on table "public"."tradelines" to "service_role";

grant select on table "public"."tradelines" to "service_role";

grant trigger on table "public"."tradelines" to "service_role";

grant truncate on table "public"."tradelines" to "service_role";

grant update on table "public"."tradelines" to "service_role";

grant delete on table "public"."transcripts" to "anon";

grant insert on table "public"."transcripts" to "anon";

grant references on table "public"."transcripts" to "anon";

grant select on table "public"."transcripts" to "anon";

grant trigger on table "public"."transcripts" to "anon";

grant truncate on table "public"."transcripts" to "anon";

grant update on table "public"."transcripts" to "anon";

grant delete on table "public"."transcripts" to "authenticated";

grant insert on table "public"."transcripts" to "authenticated";

grant references on table "public"."transcripts" to "authenticated";

grant select on table "public"."transcripts" to "authenticated";

grant trigger on table "public"."transcripts" to "authenticated";

grant truncate on table "public"."transcripts" to "authenticated";

grant update on table "public"."transcripts" to "authenticated";

grant delete on table "public"."transcripts" to "service_role";

grant insert on table "public"."transcripts" to "service_role";

grant references on table "public"."transcripts" to "service_role";

grant select on table "public"."transcripts" to "service_role";

grant trigger on table "public"."transcripts" to "service_role";

grant truncate on table "public"."transcripts" to "service_role";

grant update on table "public"."transcripts" to "service_role";

grant delete on table "public"."user_documents" to "anon";

grant insert on table "public"."user_documents" to "anon";

grant references on table "public"."user_documents" to "anon";

grant select on table "public"."user_documents" to "anon";

grant trigger on table "public"."user_documents" to "anon";

grant truncate on table "public"."user_documents" to "anon";

grant update on table "public"."user_documents" to "anon";

grant delete on table "public"."user_documents" to "authenticated";

grant insert on table "public"."user_documents" to "authenticated";

grant references on table "public"."user_documents" to "authenticated";

grant select on table "public"."user_documents" to "authenticated";

grant trigger on table "public"."user_documents" to "authenticated";

grant truncate on table "public"."user_documents" to "authenticated";

grant update on table "public"."user_documents" to "authenticated";

grant delete on table "public"."user_documents" to "service_role";

grant insert on table "public"."user_documents" to "service_role";

grant references on table "public"."user_documents" to "service_role";

grant select on table "public"."user_documents" to "service_role";

grant trigger on table "public"."user_documents" to "service_role";

grant truncate on table "public"."user_documents" to "service_role";

grant update on table "public"."user_documents" to "service_role";

grant delete on table "public"."user_roles" to "anon";

grant insert on table "public"."user_roles" to "anon";

grant references on table "public"."user_roles" to "anon";

grant select on table "public"."user_roles" to "anon";

grant trigger on table "public"."user_roles" to "anon";

grant truncate on table "public"."user_roles" to "anon";

grant update on table "public"."user_roles" to "anon";

grant delete on table "public"."user_roles" to "authenticated";

grant insert on table "public"."user_roles" to "authenticated";

grant references on table "public"."user_roles" to "authenticated";

grant select on table "public"."user_roles" to "authenticated";

grant trigger on table "public"."user_roles" to "authenticated";

grant truncate on table "public"."user_roles" to "authenticated";

grant update on table "public"."user_roles" to "authenticated";

grant delete on table "public"."user_roles" to "service_role";

grant insert on table "public"."user_roles" to "service_role";

grant references on table "public"."user_roles" to "service_role";

grant select on table "public"."user_roles" to "service_role";

grant trigger on table "public"."user_roles" to "service_role";

grant truncate on table "public"."user_roles" to "service_role";

grant update on table "public"."user_roles" to "service_role";

create policy "Authenticated users can delete their own audit history records."
on "public"."audit_history"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = performed_by));


create policy "Authenticated users can insert records into audit history."
on "public"."audit_history"
as permissive
for insert
to authenticated
with check (true);


create policy "Authenticated users can select their own audit history."
on "public"."audit_history"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = performed_by));


create policy "Authenticated users can update their own audit history records."
on "public"."audit_history"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = performed_by))
with check (true);


create policy "Authenticated users can delete their own credit bureau records."
on "public"."credit_bureau"
as permissive
for delete
to authenticated
using (true);


create policy "Authenticated users can insert records into credit bureau."
on "public"."credit_bureau"
as permissive
for insert
to authenticated
with check (true);


create policy "Authenticated users can select their own credit bureau records."
on "public"."credit_bureau"
as permissive
for select
to authenticated
using (true);


create policy "Authenticated users can update their own credit bureau records."
on "public"."credit_bureau"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "Users can manage their own credit reports"
on "public"."credit_reports"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "Allow authenticated users to delete their own dispute letters"
on "public"."dispute_letter"
as permissive
for delete
to authenticated
using (true);


create policy "Allow authenticated users to insert their own dispute letters"
on "public"."dispute_letter"
as permissive
for insert
to authenticated
with check (true);


create policy "Allow authenticated users to update their own dispute letters"
on "public"."dispute_letter"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "Users can manage their own dispute letters"
on "public"."dispute_letter"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "delete_own_dispute"
on "public"."dispute_log"
as permissive
for delete
to public
using ((user_id = auth.uid()));


create policy "insert_dispute"
on "public"."dispute_log"
as permissive
for insert
to public
with check ((user_id = auth.uid()));


create policy "select_own_disputes"
on "public"."dispute_log"
as permissive
for select
to public
using ((user_id = auth.uid()));


create policy "update_own_dispute"
on "public"."dispute_log"
as permissive
for update
to public
using ((user_id = auth.uid()));


create policy "Admins can read all disputes"
on "public"."disputes"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM user_roles
  WHERE ((user_roles.user_id = auth.uid()) AND (user_roles.role = 'admin'::text)))));


create policy "Users can manage their own disputes"
on "public"."disputes"
as permissive
for all
to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "delete_disputes"
on "public"."disputes"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "insert_disputes"
on "public"."disputes"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "select_disputes"
on "public"."disputes"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "update_disputes"
on "public"."disputes"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Authenticated users can delete their own documents"
on "public"."documents"
as permissive
for delete
to authenticated
using ((user_id = auth.uid()));


create policy "Authenticated users can insert their own documents"
on "public"."documents"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "Authenticated users can select their own documents"
on "public"."documents"
as permissive
for select
to authenticated
using ((user_id = auth.uid()));


create policy "Authenticated users can update their own documents"
on "public"."documents"
as permissive
for update
to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


create policy "Enable read access for all users"
on "public"."documents"
as restrictive
for all
to authenticated
using (true);


create policy "Allow authenticated users to insert their own profiles"
on "public"."profiles"
as permissive
for insert
to authenticated
with check (true);


create policy "Allow authenticated users to update their own profiles"
on "public"."profiles"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Allow insert for own profile"
on "public"."profiles"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Allow update for authenticated users"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Authenticated users can delete their own profiles"
on "public"."profiles"
as permissive
for delete
to authenticated
using ((id = auth.uid()));


create policy "Authenticated users can delete their own profiles."
on "public"."profiles"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Authenticated users can insert their own profiles"
on "public"."profiles"
as permissive
for insert
to authenticated
with check ((id = auth.uid()));


create policy "Authenticated users can insert their own profiles."
on "public"."profiles"
as permissive
for insert
to authenticated
with check ((user_id = ( SELECT auth.uid() AS uid)));


create policy "Authenticated users can select their own profiles"
on "public"."profiles"
as permissive
for select
to authenticated
using ((id = auth.uid()));


create policy "Authenticated users can select their own profiles."
on "public"."profiles"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Authenticated users can update their own profiles"
on "public"."profiles"
as permissive
for update
to authenticated
using ((id = auth.uid()))
with check ((id = auth.uid()));


create policy "Authenticated users can update their own profiles."
on "public"."profiles"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((user_id = ( SELECT auth.uid() AS uid)));


create policy "Allow authenticated users to delete their own tradelines"
on "public"."tradelines"
as permissive
for delete
to authenticated
using ((user_id = auth.uid()));


create policy "Allow authenticated users to insert their own tradelines"
on "public"."tradelines"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "Allow authenticated users to update their own tradelines"
on "public"."tradelines"
as permissive
for update
to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


create policy "Users can manage their own tradelines"
on "public"."tradelines"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "Users can read their own tradelines"
on "public"."tradelines"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Delete own transcripts"
on "public"."transcripts"
as permissive
for delete
to public
using ((id = auth.uid()));


create policy "Insert transcripts"
on "public"."transcripts"
as permissive
for insert
to public
with check ((id = auth.uid()));


create policy "Select own transcripts"
on "public"."transcripts"
as permissive
for select
to public
using ((id = auth.uid()));


create policy "Update own transcripts"
on "public"."transcripts"
as permissive
for update
to public
using ((id = auth.uid()));


create policy "Allow authenticated users to add documents"
on "public"."user_documents"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "Allow authenticated users to delete their own documents"
on "public"."user_documents"
as permissive
for delete
to authenticated
using ((user_id = auth.uid()));


create policy "Allow authenticated users to update their own documents"
on "public"."user_documents"
as permissive
for update
to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


create policy "Allow authenticated users to delete their own personal info"
on "public"."user_personal_info"
as permissive
for delete
to authenticated
using ((user_id = auth.uid()));


create policy "Allow authenticated users to insert their own personal info"
on "public"."user_personal_info"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "Allow authenticated users to update their own personal info"
on "public"."user_personal_info"
as permissive
for update
to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


create policy "Authenticated users can delete their own personal info."
on "public"."user_personal_info"
as permissive
for delete
to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));


create policy "Authenticated users can insert their own personal info."
on "public"."user_personal_info"
as permissive
for insert
to authenticated
with check ((user_id = ( SELECT auth.uid() AS uid)));


create policy "Authenticated users can select their own personal info."
on "public"."user_personal_info"
as permissive
for select
to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));


create policy "Authenticated users can update their own personal info."
on "public"."user_personal_info"
as permissive
for update
to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)))
with check ((user_id = ( SELECT auth.uid() AS uid)));


create policy "Allow system to change user roles to admin"
on "public"."user_roles"
as permissive
for update
to authenticated
using ((role = 'admin'::text))
with check (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM user_roles user_roles_1
  WHERE ((user_roles_1.user_id = auth.uid()) AND (user_roles_1.role = 'admin'::text))))));


CREATE TRIGGER inactive_profile_update BEFORE UPDATE ON public.disputes FOR EACH ROW EXECUTE FUNCTION prevent_inactive_update();

CREATE TRIGGER trigger_name AFTER INSERT OR DELETE OR UPDATE ON public.disputes FOR EACH ROW EXECUTE FUNCTION log_dispute_changes();

CREATE TRIGGER update_last_modified_trigger BEFORE UPDATE ON public.disputes FOR EACH ROW EXECUTE FUNCTION update_last_modified();


